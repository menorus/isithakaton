import asyncio
from geopy.geocoders import Nominatim
from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
import config
from yandex_gpt import YandexGPT,YandexMaps
from optimazer import RouteOptimizer
from parserxsl import Parser
from keybords import Keybord

LANDMARKS = Parser.output_lendmarks()

bot = Bot(token=config.TELEGRAM_TOKEN)
dp = Dispatcher()

user_data = {}

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è YandexGPT 
yandex_gpt = YandexGPT(
    api_key=getattr(config, 'YANDEX_GPT_API_KEY', ''),
    folder_id=getattr(config, 'YANDEX_FOLDER_ID', ''),
    LANDMARKS = LANDMARKS
)

INTERESTS_LIST = Keybord.create_interests_keyboard(LANDMARKS)
route_optimizer = RouteOptimizer(LANDMARKS)

@dp.message(Command("start"))
async def cmd_start(message: types.Message):
    user_id = message.from_user.id
    user_data[user_id] = {"step": "waiting_interest"}
    
    welcome_text = f"""
{YandexMaps.EMOJI['welcome']} **–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –≤–∞—à –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π AI-–≥–∏–¥ –ø–æ –ù–∏–∂–Ω–µ–º—É –ù–æ–≤–≥–æ—Ä–æ–¥—É!** üåÜ

‚ú® **–ß—Ç–æ —è —É–º–µ—é:**
‚Ä¢ üéØ –°–æ–∑–¥–∞—é –º–∞—Ä—à—Ä—É—Ç—ã –ø–æ –≤–∞—à–∏–º –∏–Ω—Ç–µ—Ä–µ—Å–∞–º
‚Ä¢ ‚è±Ô∏è –ü–æ–¥–±–∏—Ä–∞—é –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–µ—Å—Ç –ø–æ–¥ –≤–∞—à–µ –≤—Ä–µ–º—è
‚Ä¢ ü§ñ –ì–µ–Ω–µ—Ä–∏—Ä—É—é —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –æ–ø–∏—Å–∞–Ω–∏—è —Å –ø–æ–º–æ—â—å—é AI
‚Ä¢ üó∫Ô∏è –°—Ç—Ä–æ—é —É–¥–æ–±–Ω—ã–µ –º–∞—Ä—à—Ä—É—Ç—ã —Å –Ω–∞–≤–∏–≥–∞—Ü–∏–µ–π

üöÄ **–ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç:**
1. –í—ã–±–µ—Ä–∏—Ç–µ —á—Ç–æ –≤–∞–º –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ {YandexMaps.EMOJI['interest']}
2. –£–∫–∞–∂–∏—Ç–µ —Å–∫–æ–ª—å–∫–æ –≤—Ä–µ–º–µ–Ω–∏ –µ—Å—Ç—å {YandexMaps.EMOJI['time']}
3. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –≤–∞—à–µ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ {YandexMaps.EMOJI['location']}
4. –ü–æ–ª—É—á–∏—Ç–µ –≥–æ—Ç–æ–≤—ã–π –º–∞—Ä—à—Ä—É—Ç! {YandexMaps.EMOJI['route']}

üé® **–î–æ—Å—Ç—É–ø–Ω—ã–µ –∏–Ω—Ç–µ—Ä–µ—Å—ã:**
‚Ä¢ –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –∏ –∏—Å—Ç–æ—Ä–∏—è üèõÔ∏è
‚Ä¢ –ò—Å–∫—É—Å—Å—Ç–≤–æ –∏ –∫—É–ª—å—Ç—É—Ä–∞ üé®  
‚Ä¢ –ü–∞—Ä–∫–∏ –∏ –ø—Ä–∏—Ä–æ–¥–∞ üå≥
‚Ä¢ –ö–∞—Ñ–µ –∏ —Ä–µ—Å—Ç–æ—Ä–∞–Ω—ã üç¥
‚Ä¢ –®–æ–ø–ø–∏–Ω–≥ –∏ —Ä–∞–∑–≤–ª–µ—á–µ–Ω–∏—è üõçÔ∏è
‚Ä¢ –ò –º–Ω–æ–≥–æ–µ –¥—Ä—É–≥–æ–µ!

{YandexMaps.EMOJI['ai']} *–í—Å–µ –æ–ø–∏—Å–∞–Ω–∏—è —Å–æ–∑–¥–∞—é—Ç—Å—è –∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–º –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç–æ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ –¥–ª—è –≤–∞—Å*


üëá **–í—ã–±–µ—Ä–∏—Ç–µ, —á—Ç–æ –≤–∞—Å –∏–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç, –∏ –Ω–∞—á–Ω–µ–º –Ω–∞—à–µ –ø—É—Ç–µ—à–µ—Å—Ç–≤–∏–µ!**
"""
    
    await message.answer(welcome_text, parse_mode="Markdown", reply_markup=Keybord.get_interests_keyboard(INTERESTS_LIST))

@dp.message(lambda message: message.text == "üìù –í–≤–µ—Å—Ç–∏ –∞–¥—Ä–µ—Å –≤—Ä—É—á–Ω—É—é")
async def handle_manual_location_request(message: types.Message):
    user_id = message.from_user.id
    
    if user_id not in user_data or user_data[user_id].get("step") != "waiting_location":
        user_data[user_id] = {"step": "waiting_interest"}
        await message.answer("–î–∞–≤–∞–π—Ç–µ –Ω–∞—á–Ω–µ–º —Å–Ω–∞—á–∞–ª–∞. –í—ã–±–µ—Ä–∏—Ç–µ –∏–Ω—Ç–µ—Ä–µ—Å:", reply_markup=Keybord.get_interests_keyboard(INTERESTS_LIST))
        return
    
    user_data[user_id]["step"] = "waiting_address"
    
    await message.answer(
        f"{YandexMaps.EMOJI['location']} **–ù–∞–ø–∏—à–∏—Ç–µ –≤–∞—à –∞–¥—Ä–µ—Å:**\n(–ù–∞–ø—Ä–∏–º–µ—Ä: —É–ª. –ë–æ–ª—å—à–∞—è –ü–æ–∫—Ä–æ–≤—Å–∫–∞—è, 1)",
        parse_mode="Markdown",
        reply_markup=types.ReplyKeyboardRemove()
    )

@dp.message(lambda message: user_data.get(message.from_user.id, {}).get("step") == "waiting_address")
async def handle_address_input(message: types.Message):
    user_id = message.from_user.id
    user_data[user_id]["step"] = "processing_address"
    
    loading_msg = await message.answer(f"{YandexMaps.EMOJI['loading']} **–û–ø—Ä–µ–¥–µ–ª—è—é –∞–¥—Ä–µ—Å...**", parse_mode="Markdown")
    
    try:
        geolocator = Nominatim(user_agent="ai-tour-bot")
        location = geolocator.geocode(f"{message.text}, –ù–∏–∂–Ω–∏–π –ù–æ–≤–≥–æ—Ä–æ–¥")
        
        if not location:
            await loading_msg.edit_text(f"{YandexMaps.EMOJI['error']} **–ê–¥—Ä–µ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω.** –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–æ–π –≤–∞—Ä–∏–∞–Ω—Ç.")
            user_data[user_id]["step"] = "waiting_location"
            await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ —Å–ø–æ—Å–æ–±:", reply_markup=Keybord.get_location_keyboard())
            return
        
        user_data[user_id]["location"] = (location.latitude, location.longitude)
        user_data[user_id]["step"] = "processing"
        
        await loading_msg.edit_text(f"{YandexMaps.EMOJI['success']} **–ê–¥—Ä–µ—Å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω!** –°–æ–∑–¥–∞—é –º–∞—Ä—à—Ä—É—Ç... {YandexMaps.EMOJI['ai']}")
        await generate_and_send_route(message)
        
    except Exception as e:
        await loading_msg.edit_text(f"{YandexMaps.EMOJI['error']} **–û—à–∏–±–∫–∞.** –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.")
        user_data[user_id]["step"] = "waiting_location"
        await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ —Å–ø–æ—Å–æ–±:", reply_markup=Keybord.get_location_keyboard())


async def generate_and_send_route(message: types.Message):
    user_id = message.from_user.id
    user_session = user_data.get(user_id, {})
    
    try:
        interest = user_session.get("interest", "")
        location = user_session.get("location", (56.326887, 44.005986))
        available_time = user_session.get("time", "2 —á–∞—Å–∞")
        
        # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–µ—Å—Ç –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—Ä–µ–º–µ–Ω–∏
        places_count = route_optimizer.calculate_places_by_time(available_time)
        
        # –ü–æ–ª—É—á–∞–µ–º –¥–æ—Å—Ç–æ–ø—Ä–∏–º–µ—á–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –ø–æ –∏–Ω—Ç–µ—Ä–µ—Å—É
        landmarks = route_optimizer.get_landmarks_by_interest(interest, max_landmarks=15)
        
        if not landmarks:
            await message.answer(
                f"‚ùå **–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –Ω–µ –Ω–∞—à–ª–æ—Å—å –º–µ—Å—Ç –ø–æ –≤–∞—à–µ–º—É –∏–Ω—Ç–µ—Ä–µ—Å—É**\n\n"
                f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –≤—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥—É—é –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∏–ª–∏ '–õ—é–±—ã–µ –¥–æ—Å—Ç–æ–ø—Ä–∏–º–µ—á–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏' üåü",
                reply_markup=Keybord.get_action_keyboard()
            )
            return
        
        # –°–æ–∑–¥–∞–µ–º –º–∞—Ä—à—Ä—É—Ç —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É –º–µ—Å—Ç
        route = route_optimizer.find_optimal_route(landmarks, location, max_places=places_count)
        
        if not route:
            await message.answer(
                f"‚ùå **–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –º–∞—Ä—à—Ä—É—Ç**\n\n"
                f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∏–∑–º–µ–Ω–∏—Ç—å –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ –∏–ª–∏ –≤—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥–∏–µ –∏–Ω—Ç–µ—Ä–µ—Å—ã üîÑ",
                reply_markup=Keybord.get_action_keyboard()
            )
            return
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –º–∞—Ä—à—Ä—É—Ç –≤ —Å–µ—Å—Å–∏–∏
        user_data[user_id]["current_route"] = route
        
        # –û–±–Ω–æ–≤–ª—è–µ–º —Ä–µ–π—Ç–∏–Ω–≥–∏ –¥–ª—è –º–µ—Å—Ç –≤ –º–∞—Ä—à—Ä—É—Ç–µ
        rating_update_msg = await message.answer(
            f"üîç **–û–±–Ω–æ–≤–ª—è—é –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ —Ä–µ–π—Ç–∏–Ω–≥–∏...**\n"
            f"‚è≥ *–ó–∞–ø—Ä–∞—à–∏–≤–∞—é —Å–≤–µ–∂–∏–µ –æ—Ü–µ–Ω–∫–∏ –∏–∑ –Ø–Ω–¥–µ–∫—Å –ö–∞—Ä—Ç*"
        )
        
        for landmark in route:
            if landmark in LANDMARKS:
                try:
                    if yandex_data and yandex_data.get('rating'):
                        LANDMARKS[landmark]['yandex_rating'] = yandex_data['rating']
                        LANDMARKS[landmark]['yandex_data'] = yandex_data
                    await asyncio.sleep(0.3)
                except Exception as e:
                    continue
        
        await rating_update_msg.delete()
        
        ai_intro_message = await message.answer(
            f"üé® –°–æ–∑–¥–∞—é —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –æ–ø–∏—Å–∞–Ω–∏—è...\n"
            f"ü§ñ –ò—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç –≥–æ—Ç–æ–≤–∏—Ç —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ –¥–ª—è –≤–∞—Å"
        )
        
        personal_recommendation = await yandex_gpt.generate_personal_recommendation(
            route, interest, available_time
        )
        
        await ai_intro_message.edit_text("‚ú® –û–ø–∏—Å–∞–Ω–∏—è –≥–æ—Ç–æ–≤—ã!")
        
        route_map_keyboard = YandexMaps.generate_full_route_map_button(route, location,LANDMARKS)
        
        await message.answer(
            f"üéØ **–í–ê–® –ü–ï–†–°–û–ù–ê–õ–¨–ù–´–ô –ú–ê–†–®–†–£–¢ –ì–û–¢–û–í!**\n\n"
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
            f"üìã **–û–°–ù–û–í–ù–ê–Ø –ò–ù–§–û–†–ú–ê–¶–ò–Ø**\n"
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            f"üéØ **–ò–Ω—Ç–µ—Ä–µ—Å:** {interest}\n"
            f"‚è±Ô∏è **–í—Ä–µ–º—è:** {available_time}\n"
            f"üìç **–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–µ—Å—Ç:** {len(route)}\n"
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
            f"üí´ **–ü–ï–†–°–û–ù–ê–õ–¨–ù–ê–Ø –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø**\n"
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            f"_{personal_recommendation}_\n\n"
            f"üëá **–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –º–∞—Ä—à—Ä—É—Ç–∞ –Ω–∞ –∫–∞—Ä—Ç–µ**",
            parse_mode="Markdown",
            reply_markup=route_map_keyboard
        )
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–∞–∂–¥–æ–µ –º–µ—Å—Ç–æ –æ—Ç–¥–µ–ª—å–Ω—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º
        for i, landmark in enumerate(route, 1):
            if landmark in LANDMARKS:
                landmark_data = LANDMARKS[landmark]
                
                # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–ª—É—á—à–µ–Ω–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ
                enhanced_description = await yandex_gpt.enhance_landmark_description(
                    landmark, landmark_data, interest
                )
                
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä–µ–π—Ç–∏–Ω–≥ –∏–∑ –Ø–Ω–¥–µ–∫—Å –ö–∞—Ä—Ç –µ—Å–ª–∏ –µ—Å—Ç—å
               # current_rating = landmark_data.get('yandex_rating') or landmark_data['rating']
               # rating_source = "‚≠ê –Ø–Ω–¥–µ–∫—Å –ö–∞—Ä—Ç—ã" if landmark_data.get('yandex_rating') else "‚≠ê –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö"
                
                landmark_message = (
                    f"üìç **{i}. {landmark}**\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üìñ **–û–ø–∏—Å–∞–Ω–∏–µ:**\n"
                    f"_{enhanced_description}_\n\n"
                )
                
                # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–∑ –Ø–Ω–¥–µ–∫—Å –ö–∞—Ä—Ç –µ—Å–ª–∏ –µ—Å—Ç—å
                yandex_data = landmark_data.get('yandex_data', {})
                if yandex_data.get('address'):
                    landmark_message += f"üè† **–ê–¥—Ä–µ—Å:** {yandex_data['address']}\n"
                
                if yandex_data.get('reviews'):
                    landmark_message += f"üí¨ **–û—Ç–∑—ã–≤–æ–≤:** {yandex_data['reviews']}\n"
                
                if landmark_data.get('features'):
                    features = " | ".join([f"‚ú® {f}" for f in landmark_data['features'][:3]])
                
                
                # –ü–æ–ª—É—á–∞–µ–º –∫–Ω–æ–ø–∫—É –¥–ª—è –∫–∞—Ä—Ç—ã
                map_keyboard = YandexMaps.generate_individual_map_button(landmark,LANDMARKS)
                
                await message.answer(landmark_message, parse_mode="Markdown", reply_markup=map_keyboard)
                await asyncio.sleep(0.5)
        
        # –°—á–∏—Ç–∞–µ–º —Å—Ä–µ–¥–Ω–∏–π —Ä–µ–π—Ç–∏–Ω–≥ –º–∞—Ä—à—Ä—É—Ç–∞
        total_rating = 0
        rated_places = 0
        for landmark in route:
            if landmark in LANDMARKS:
                rating = LANDMARKS[landmark].get('yandex_rating') or LANDMARKS[landmark]['rating']
                total_rating += rating
                rated_places += 1
        
        avg_rating = total_rating / rated_places if rated_places > 0 else 0
        
        # –§–∏–Ω–∞–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–Ω–æ–ø–∫–∞–º–∏
        final_keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text=f"üó∫Ô∏è –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –≤–µ—Å—å –º–∞—Ä—à—Ä—É—Ç –Ω–∞ –∫–∞—Ä—Ç–µ", 
                                url=YandexMaps.generate_route_map_link(route, location,LANDMARKS))],
            [InlineKeyboardButton(text=f"üîÑ –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –º–∞—Ä—à—Ä—É—Ç", callback_data="restart")]
        ])
        
        await message.answer(
            f"üéâ –ú–ê–†–®–†–£–¢ –£–°–ü–ï–®–ù–û –°–û–ó–î–ê–ù!\n\n"
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
            f"üìä –ò–¢–û–ì–ò\n"
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            f"‚úÖ –ì–æ—Ç–æ–≤–æ: –ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –º–∞—Ä—à—Ä—É—Ç\n"
            f"‚è±Ô∏è –í—Ä–µ–º—è –ø—Ä–æ–≥—É–ª–∫–∏: {available_time}\n"
            f"üìç –¢–æ—á–µ–∫ –ø–æ—Å–µ—â–µ–Ω–∏—è: {len(route)}\n"
            f"üéØ –ö–∞—Ç–µ–≥–æ—Ä–∏—è: {interest}\n\n"
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
            f"üí° –°–û–í–ï–¢–´ –î–õ–Ø –ü–£–¢–ï–®–ï–°–¢–í–ï–ù–ù–ò–ö–ê\n"
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            f"üó∫Ô∏è –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –Ø–Ω–¥–µ–∫—Å –ö–∞—Ä—Ç—ã –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏\n"
            f"üì∏ –ù–µ –∑–∞–±—ã–≤–∞–π—Ç–µ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—Ä–æ–≤–∞—Ç—å –∫—Ä–∞—Å–∏–≤—ã–µ –º–µ—Å—Ç–∞\n"
            f"‚è∞ –£—á–∏—Ç—ã–≤–∞–π—Ç–µ –≤—Ä–µ–º—è –Ω–∞ –¥–æ—Ä–æ–≥—É –º–µ–∂–¥—É —Ç–æ—á–∫–∞–º–∏\n"
            f"üéí –ë–µ—Ä–∏—Ç–µ —É–¥–æ–±–Ω—É—é –æ–±—É–≤—å –¥–ª—è –ø—Ä–æ–≥—É–ª–∫–∏\n\n"
            f"‚ú® –ü—Ä–∏—è—Ç–Ω–æ–≥–æ –ø—É—Ç–µ—à–µ—Å—Ç–≤–∏—è –ø–æ –ù–∏–∂–Ω–µ–º—É –ù–æ–≤–≥–æ—Ä–æ–¥—É! üåÜ",
            reply_markup=final_keyboard
        )
        
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞: {e}")
        await message.answer(
            f"üòî **–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞**\n\n"
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
            f"üîÑ **–ü–û–ü–†–û–ë–£–ô–¢–ï –ï–©–ï –†–ê–ó**\n"
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            f"‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É\n"
            f"‚Ä¢ –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–æ–π –∏–Ω—Ç–µ—Ä–µ—Å\n"
            f"‚Ä¢ –£–±–µ–¥–∏—Ç–µ—Å—å –≤ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏ –ª–æ–∫–∞—Ü–∏–∏\n\n"
            f"üëá –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ –¥–ª—è –Ω–æ–≤–æ–≥–æ –º–∞—Ä—à—Ä—É—Ç–∞",
            reply_markup=Keybord.get_action_keyboard()
        )

@dp.message(lambda message: message.text in INTERESTS_LIST)
async def handle_interest_selection(message: types.Message):
    user_id = message.from_user.id
    
    if user_id not in user_data or user_data[user_id].get("step") != "waiting_interest":
        user_data[user_id] = {"step": "waiting_interest"}
        await message.answer(
            f"üîÑ **–ù–∞—á–Ω–µ–º —Å–Ω–∞—á–∞–ª–∞!**\n\n"
            f"üëá –í—ã–±–µ—Ä–∏—Ç–µ –∏–Ω—Ç–µ—Ä–µ—Å –∏–∑ –º–µ–Ω—é –Ω–∏–∂–µ:",
            reply_markup=Keybord.get_interests_keyboard(INTERESTS_LIST)
        )
        return
    
    user_data[user_id] = {
        "step": "waiting_time",
        "interest": message.text
    }
    
    response_text = (
        f"‚úÖ **–û—Ç–ª–∏—á–Ω—ã–π –≤—ã–±–æ—Ä!** {message.text}\n\n"
        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        f"‚è∞ **–í–´–ë–ï–†–ò–¢–ï –í–†–ï–ú–Ø –ü–†–û–ì–£–õ–ö–ò**\n"
        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        f"‚ú® **–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –≤—Ä–µ–º–µ–Ω–∏:**\n\n"
        f"‚Ä¢ üïê 1 —á–∞—Å ‚Üí 2 –º–µ—Å—Ç–∞\n"
        f"‚Ä¢ üïë 2 —á–∞—Å–∞ ‚Üí 3 –º–µ—Å—Ç–∞  \n"
        f"‚Ä¢ üïí 3 —á–∞—Å–∞ ‚Üí 4 –º–µ—Å—Ç–∞\n"
        f"‚Ä¢ üïì 4 —á–∞—Å–∞ ‚Üí 5 –º–µ—Å—Ç\n\n"
        f"üëá **–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–¥—Ö–æ–¥—è—â–∏–π –≤–∞—Ä–∏–∞–Ω—Ç:**"
    )
    
    await message.answer(response_text, parse_mode="Markdown", reply_markup=Keybord.get_time_keyboard())

@dp.message(lambda message: message.text in ["1 —á–∞—Å", "2 —á–∞—Å–∞", "3 —á–∞—Å–∞", "4 —á–∞—Å–∞"])
async def handle_time_selection(message: types.Message):
    user_id = message.from_user.id
    
    if user_id not in user_data or user_data[user_id].get("step") != "waiting_time":
        user_data[user_id] = {"step": "waiting_interest"}
        await message.answer(
            f"üîÑ **–ù–∞—á–Ω–µ–º —Å–Ω–∞—á–∞–ª–∞!**\n\n"
            f"üëá –í—ã–±–µ—Ä–∏—Ç–µ –∏–Ω—Ç–µ—Ä–µ—Å –∏–∑ –º–µ–Ω—é –Ω–∏–∂–µ:",
            reply_markup=Keybord.get_interests_keyboard(INTERESTS_LIST)
        )
        return
    
    user_data[user_id]["step"] = "waiting_location"
    user_data[user_id]["time"] = message.text
    
    # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–µ—Å—Ç
    places_count = route_optimizer.calculate_places_by_time(message.text)
    
    response_text = (
        f"‚úÖ **–ó–∞–ø–æ–º–Ω–∏–ª!** {message.text}\n\n"
        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        f"üìç **–£–ö–ê–ñ–ò–¢–ï –í–ê–®–ï –ú–ï–°–¢–û–ü–û–õ–û–ñ–ï–ù–ò–ï**\n"
        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        f"üìä **–ë—É–¥–µ—Ç –ø–æ–¥–æ–±—Ä–∞–Ω–æ:** {places_count} –º–µ—Å—Ç\n\n"
        f"‚ú® **–î–æ—Å—Ç—É–ø–Ω—ã–µ —Å–ø–æ—Å–æ–±—ã:**\n\n"
        f"‚Ä¢ üìç –û—Ç–ø—Ä–∞–≤–∏—Ç—å –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é (—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è)\n"
        f"‚Ä¢ üìù –í–≤–µ—Å—Ç–∏ –∞–¥—Ä–µ—Å –≤—Ä—É—á–Ω—É—é\n\n"
        f"üëá **–í—ã–±–µ—Ä–∏—Ç–µ —É–¥–æ–±–Ω—ã–π —Å–ø–æ—Å–æ–±:**"
    )
    
    await message.answer(response_text, parse_mode="Markdown", reply_markup=Keybord.get_location_keyboard())

@dp.message(lambda message: message.location is not None)
async def handle_location(message: types.Message):
    user_id = message.from_user.id
    
    if user_id not in user_data or user_data[user_id].get("step") != "waiting_location":
        user_data[user_id] = {"step": "waiting_interest"}
        await message.answer(
            f"üîÑ **–ù–∞—á–Ω–µ–º —Å–Ω–∞—á–∞–ª–∞!**\n\n"
            f"üëá –í—ã–±–µ—Ä–∏—Ç–µ –∏–Ω—Ç–µ—Ä–µ—Å –∏–∑ –º–µ–Ω—é –Ω–∏–∂–µ:",
            reply_markup=Keybord.get_interests_keyboard(INTERESTS_LIST)
        )
        return
    
    location = message.location
    user_data[user_id]["location"] = (location.latitude, location.longitude)
    user_data[user_id]["step"] = "processing"
    
    await message.answer(
        f"üé® **–°–û–ó–î–ê–Æ –í–ê–® –ü–ï–†–°–û–ù–ê–õ–¨–ù–´–ô –ú–ê–†–®–†–£–¢...**\n\n"
        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        f"üîÑ **–≠–¢–ê–ü–´ –û–ë–†–ê–ë–û–¢–ö–ò**\n"
        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        f"üîç –ü–æ–∏—Å–∫ –ª—É—á—à–∏—Ö –º–µ—Å—Ç...\n"
        f"üó∫Ô∏è –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –º–∞—Ä—à—Ä—É—Ç–∞...\n"
        f"‚≠ê –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä–µ–π—Ç–∏–Ω–≥–æ–≤...\n"
        f"ü§ñ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ–ø–∏—Å–∞–Ω–∏–π...\n\n"
        f"‚è≥ *–≠—Ç–æ –∑–∞–π–º–µ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥*",
        parse_mode="Markdown"
    )
    await generate_and_send_route(message)

@dp.callback_query(lambda c: c.data == "restart")
async def handle_restart(callback: types.CallbackQuery):
    user_id = callback.from_user.id
    user_data[user_id] = {"step": "waiting_interest"}
    
    await callback.answer("‚ú® –ù–∞—á–∏–Ω–∞–µ–º –Ω–æ–≤—ã–π –º–∞—Ä—à—Ä—É—Ç!")
    await callback.message.answer(
        f"üîÑ **–°–û–ó–î–ê–ï–ú –ù–û–í–´–ô –ú–ê–†–®–†–£–¢**\n\n"
        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        f"üéØ **–í–´–ë–ï–†–ò–¢–ï –ò–ù–¢–ï–†–ï–°**\n"
        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        f"‚ú® –ö—É–¥–∞ –æ—Ç–ø—Ä–∞–≤–∏–º—Å—è –Ω–∞ —ç—Ç–æ—Ç —Ä–∞–∑?\n\n"
        f"üëá **–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∏–∑ –º–µ–Ω—é:**",
        parse_mode="Markdown",
        reply_markup=Keybord.get_interests_keyboard(INTERESTS_LIST)
    )

@dp.message()
async def handle_other_messages(message: types.Message):
    user_id = message.from_user.id
    
    if user_id not in user_data:
        await message.answer(f"{YandexMaps.EMOJI['welcome']} –ù–∞–ø–∏—à–∏—Ç–µ /start —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å!")
        return
    
    current_step = user_data[user_id].get("step", "")
    
    if current_step == "waiting_interest":
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∏–Ω—Ç–µ—Ä–µ—Å –∏–∑ –º–µ–Ω—é –Ω–∏–∂–µ:", reply_markup=Keybord.get_interests_keyboard(INTERESTS_LIST))
    elif current_step == "waiting_time":
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –≤—Ä–µ–º—è –∏–∑ –º–µ–Ω—é –Ω–∏–∂–µ:", reply_markup=Keybord.get_time_keyboard())
    elif current_step == "waiting_location":
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Å–ø–æ—Å–æ–± —É–∫–∞–∑–∞–Ω–∏—è –ª–æ–∫–∞—Ü–∏–∏:", reply_markup=Keybord.get_location_keyboard())
    elif current_step == "waiting_address":
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à –∞–¥—Ä–µ—Å –≤ –ù–∏–∂–Ω–µ–º –ù–æ–≤–≥–æ—Ä–æ–¥–µ:")
    else:
        await message.answer(f"{YandexMaps.EMOJI['error']} –ù–µ –ø–æ–Ω–∏–º–∞—é –∫–æ–º–∞–Ω–¥—É. –ù–∞–ø–∏—à–∏—Ç–µ /start —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ.")

async def main():
    print(f"üöÄ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω! –ì–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ...")
    print(f"üìç –ó–∞–≥—Ä—É–∂–µ–Ω–æ –¥–æ—Å—Ç–æ–ø—Ä–∏–º–µ—á–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–µ–π: {len(LANDMARKS)}")
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å YandexGPT
    if hasattr(config, 'YANDEX_GPT_API_KEY') and config.YANDEX_GPT_API_KEY:
        print(f"ü§ñ YandexGPT: –í–ö–õ–Æ–ß–ï–ù")
    else:
        print(f"‚ö†Ô∏è YandexGPT: –û–¢–ö–õ–Æ–ß–ï–ù (–¥–æ–±–∞–≤—å—Ç–µ –∫–ª—é—á–∏ –≤ config.py)")
    
    # –í—ã–≤–æ–¥–∏–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º
    categories_count = {}
    for name, data in LANDMARKS.items():
        category = data['category']
        categories_count[category] = categories_count.get(category, 0) + 1
    
    print("üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º:")
    for category, count in categories_count.items():
        print(f"  - {category}: {count} –æ–±—ä–µ–∫—Ç–æ–≤")
    
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())